# 基础语法学习

<cite>
**本文档中引用的文件**  
- [hello.go](file://1-firstGolang/hello.go)
- [test1_var.go](file://2-var/test1_var.go)
- [test2_const.go](file://3-const_iota/test2_const.go)
- [test3_function.go](file://4-function/test3_function.go)
- [main.go](file://5-init/main.go)
- [lib1.go](file://5-init/lib1/lib1.go)
- [lib2.go](file://5-init/lib2/lib2.go)
- [pointer.go](file://6-pointer/pointer.go)
- [defer.go](file://7-defer/defer.go)
- [test1_array.go](file://8-slice/test1_array.go)
- [test2_slice.go](file://8-slice/test2_slice.go)
- [test3_slice.go](file://8-slice/test3_slice.go)
- [test4_slice.go](file://8-slice/test4_slice.go)
- [test5_slice.go](file://8-slice/test5_slice.go)
- [test_map1.go](file://9-map/test_map1.go)
- [test_map2.go](file://9-map/test_map2.go)
</cite>

## 目录
1. [简介](#简介)
2. [程序结构与main函数](#程序结构与main函数)
3. [变量声明与初始化](#变量声明与初始化)
4. [常量与iota枚举](#常量与iota枚举)
5. [函数定义与返回机制](#函数定义与返回机制)
6. [包初始化与init函数](#包初始化与init函数)
7. [指针与内存操作](#指针与内存操作)
8. [defer延迟执行](#defer延迟执行)
9. [数组、切片与map](#数组、切片与map)
10. [小练习与最佳实践](#小练习与最佳实践)

## 简介
本教程系统介绍Go语言的基础语法，涵盖从程序入口到数据结构的核心知识点。通过实际代码示例，帮助学习者掌握Go语言的基本编程范式、常见错误规避方法以及编码最佳实践。

## 程序结构与main函数

Go程序以`package main`为入口包，必须包含一个`main`函数作为程序执行起点。`import`语句用于引入标准库或自定义包，支持单行或多行导入方式。

在`hello.go`中展示了标准的程序结构：包声明、多行导入、注释使用及`main`函数的固定格式。特别注意，函数左大括号`{`必须与函数名在同一行，否则编译失败。

**Section sources**
- [hello.go](file://1-firstGolang/hello.go#L1-L18)

## 变量声明与初始化

Go提供四种变量声明方式：
1. `var 变量名 类型`：声明未初始化变量，默认值为零值
2. `var 变量名 类型 = 值`：显式指定类型并初始化
3. `var 变量名 = 值`：类型由编译器自动推导
4. `变量名 := 值`：短变量声明，仅限函数体内使用

全局变量可在函数外使用前三种方式声明，而`:=`仅限局部作用域。支持多变量并行声明和批量初始化。

**Section sources**
- [test1_var.go](file://2-var/test1_var.go#L1-L70)

## 常量与iota枚举

常量使用`const`关键字定义，具有只读属性，不可修改。`iota`是Go特有的常量生成器，在`const`块中从0开始自增，适用于枚举场景。

`test2_const.go`演示了`iota`的两种典型用法：连续值枚举和带运算表达式的枚举。`iota`只能在`const`上下文中使用，每行递增1，支持数学运算组合。

**Section sources**
- [test2_const.go](file://3-const_iota/test2_const.go#L1-L43)

## 函数定义与返回机制

Go函数语法为`func 函数名(参数列表) 返回值类型 { }`。支持多返回值，可命名返回值变量以提升可读性。

`test3_function.go`展示了：
- 普通单返回值函数
- 匿名多返回值函数
- 命名返回值函数（可直接`return`而不写变量名）
- 短变量声明接收返回值

命名返回值在函数体内自动初始化为对应类型的零值，适合复杂逻辑的函数。

**Section sources**
- [test3_function.go](file://4-function/test3_function.go#L1-L67)

## 包初始化与init函数

Go程序启动时会自动调用所有导入包的`init()`函数，执行顺序为：依赖包 → 当前包。`init()`函数无参数、无返回值，用于初始化配置、注册驱动等前置操作。

`main.go`通过导入`lib1`和`lib2`包，验证其`init()`函数的执行顺序。即使包被重命名或匿名导入（`_`前缀），`init()`仍会被执行。

**Section sources**
- [main.go](file://5-init/main.go#L1-L15)
- [lib1.go](file://5-init/lib1/lib1.go#L1-L12)
- [lib2.go](file://5-init/lib2/lib2.go#L1-L12)

## 指针与内存操作

指针保存变量的内存地址，通过`&`取地址，`*`解引用。Go支持指针传递实现函数间共享内存，避免值拷贝开销。

`pointer.go`演示了：
- 使用指针交换两个变量的值
- 一级指针和二级指针的声明与使用
- `nil`指针的判断

指针在处理大型结构体或需要修改原值时尤为关键。

**Section sources**
- [pointer.go](file://6-pointer/pointer.go#L1-L43)

## defer延迟执行

`defer`语句将函数调用延迟到当前函数返回前执行，常用于资源释放（如关闭文件、解锁）。多个`defer`按后进先出（LIFO）顺序执行。

`defer.go`展示了`defer`的执行顺序：尽管`defer`语句在代码中间，但其调用被推迟到函数末尾，且多个`defer`逆序执行。

**Section sources**
- [defer.go](file://7-defer/defer.go#L1-L12)

## 数组、切片与map

### 数组与切片
数组是固定长度的同类型元素集合，切片是对数组的抽象，提供动态扩容能力。

`test1_array.go`说明数组传参为值拷贝，不影响原数组；`test2_slice.go`展示切片为引用传递。切片可通过字面量、`make`创建，支持`len`和`cap`查询。

`test3_slice.go`演示空切片判断；`test4_slice.go`展示`append`扩容机制（容量不足时自动翻倍）；`test5_slice.go`说明切片截取共享底层数组特性及`copy`函数的深拷贝作用。

### Map
Map是键值对集合，三种创建方式：
1. 先声明后`make`分配空间
2. `make(map[keyType]valueType)`
3. 字面量初始化

`test_map1.go`和`test_map2.go`演示了map的增删改查、遍历、函数传参（引用传递）和修改操作。

**Section sources**
- [test1_array.go](file://8-slice/test1_array.go#L1-L41)
- [test2_slice.go](file://8-slice/test2_slice.go#L1-L26)
- [test3_slice.go](file://8-slice/test3_slice.go#L1-L27)
- [test4_slice.go](file://8-slice/test4_slice.go#L1-L30)
- [test5_slice.go](file://8-slice/test5_slice.go#L1-L25)
- [test_map1.go](file://9-map/test_map1.go#L1-L38)
- [test_map2.go](file://9-map/test_map2.go#L1-L39)

## 小练习与最佳实践

### 常见错误分析
- **变量声明错误**：在函数外使用`:=`
- **常量修改**：尝试修改`const`定义的值
- **map未初始化**：声明后直接赋值而未`make`
- **切片越界**：访问超出`len`范围的索引
- **defer参数求值时机**：`defer`中的参数在语句执行时即确定

### 最佳实践建议
1. **变量声明**：函数内优先使用`:=`，简洁清晰
2. **常量枚举**：善用`iota`生成连续值
3. **函数设计**：多返回值用于错误处理（`value, error`）
4. **资源管理**：`defer`确保资源释放
5. **切片操作**：预估容量使用`make(slice, len, cap)`减少扩容
6. **map安全操作**：删除键前无需判断是否存在

### 小练习
1. 编写一个函数，接收两个整数指针并交换其值
2. 使用`iota`定义一周七天的常量
3. 创建一个map存储学生姓名与成绩，实现增删改查功能
4. 使用`defer`模拟文件打开关闭流程
5. 编写切片反转函数，验证是否影响原数组